\documentclass{stdlocal}
\begin{document}
\section{Introduction} % (fold)
\label{sec:introduction}

For various mathematical and physical problems, there exists no feasible, deterministic algorithm to solve them \autocite{pharr2016}.
Especially, the simulation of physical systems with many coupled degrees of freedom, such as fluids, seem to be difficult to compute due to their high dimensionality.
Instead, a class of randomized algorithms, called Monte Carlo methods, are used to approximate the actual outcome.
Monte Carlo methods rely on repeated random sampling to obtain a numerical result.
Hence, they are not bound to the curse of dimensionality and are able to evaluate complex equations quickly.

To obtain precise answers with a small relative error, Monte Carlo algorithms have to use a tremendous amount of random numbers.
But the usage of truly random numbers generated by physical processes consists at least of two drawbacks.
First, the output of the algorithm will be non-deterministic and, as a result, untestable.
Second, the generation of truly random numbers is typically based on a slow process and consequently reduces the performance of the entire program.
For that reason, Monte Carlo algorithms usually use so-called pseudorandom number generators.
PRNGs generate a sequence of numbers based on a deterministic procedure and a truly random initial value as seed.
The sequence of numbers is not truly random but fulfills several properties of truly random sequences.

The structure of Monte Carlo methods causes a program to spend most of its time with the construction of random numbers.
Even the application of PRNGs does not change that.
Today's computer processors provide functionality for the parallel execution of code in different ways, mainly SIMD and MIMD.
Hence, to efficiently use the computing power of a CPU for Monte Carlo algorithms PRNGs have to be vectorized and parallelized to exploit such features.
Whereas parallelization takes place at a high level, vectorization has to be done by the compiler or manually by the programmer at a much lower level.
The implementation of PRNGs constraints automatic vectorization due to internal flow and data dependencies.
To lift this restriction, a manual vectorization concerning data dependence and latencies appears to be the right way.

The C++ programming language is a perfect candidate for the development of vectorized PRNGs.
It is one of the most used languages in the world and can be applied to small research projects as well as large enterprise programs.
The language allows for the high-level abstraction of algorithms and structures.
On the other hand, it is capable of accessing low-level routines to exploit special hardware features, like SSE, AVX, and threads.
A typical C++ compiler is able to optimize the code with respect to such features automatically.
But we as programmers are not bound to this and can manually optimize the code further.
Every three years, a new standard is published, such as the new C++20 language specification.
The language is evolving by its communities improvements and therefore it keeps to be a modern language.
On top of this, other languages, such as Python, usually provide an interface to communicate with the C programming language.
Through the design of an efficient implementation in C++, we can easily add support for other languages as well by providing a standard C interface.

Lots of PRNGs have been implemented by different libraries with different APIs.
For example, STL, Boost, Intel MKL, RNGAVXLIB, Lemire, tinyrng,...
STL, Boost and ... provide a large set of robust PRNGs which are not vectorized but well documented.
Their API makes them likely to be used but shows many flaws.
It does not allow to explicitly use the vectorization capabilities of a PRNG, gives you a bad default seeding and makes use of standard distributions difficult and not adjustable.
Lemire and RNGAVXLIB provide open-source, vectorized implementations with bad documentation and difficult-to-use code.
Intel MKL as well provides vectorized PRNGs but is not available open-source and uses difficult interfaces.
There is not any easily-accessible, portable, open-source library which gives a coherent, easy-to-use and consistent interface for vectorized PRNGs.

In this thesis, we develop a new library, called \citetitle{pxart}, in the C++ programming language \footfullcite{pxart}.
\citetitle{pxart} vectorizes a handful of already known PRNGs which partly do not exist as vectorized versions and provides a new API for their usage to accommodate the disadvantages of the standard random library of the STL.
The library itself is header-only, open-source, and can be found on GitHub.
It is easily installable on every operating system.
Additionally, we compare the performance of our vectorized PRNGs to other already accessible implementations in Boost, Intel MKL, Lemire, RNGAVXLIB and others.
The performance is measured by speed, code size, memory size, complexity, and random properties.
Meanwhile, we apply the implementations to an example Monte Carlo simulation.
For this, a small test framework is implemented which allows us to easily test and evaluate PRNGs with respect to stated measures.

% section introduction (end)
\end{document}