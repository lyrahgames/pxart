\documentclass{stdlocal}
\begin{document}
\section{Design of the API} % (fold)
\label{sec:design_of_the_api}
  The design of an API for a library making the use of vectorized PRNGs possible consists of multiple parts.
  To exploit the statistical properties of all the implemented generators proper seeding routines have to be provided.
  Seeding of PRNGs should be easy but not magically hiding important information, like the RNG that is used for the initialization.
  The implementation of the MT19937 given by \code{std::mt19937} in the STL of the C++ programming language for example, internally uses an easier PRNG to initialize its whole state vector by only one truly random number.
  The interface of \code{std::mt19937} does not show this information to the programmer or the reader and even forces the user of the library to employ this process.
  Furthermore, a generator \code{RNG} only used for seeding will typically constructed directly as an rvalue in the constructor of the \code{std::mt19937}.
  \[
    \text{\code{std::mt19937 rng\{RNG\{\}()\};}}
  \]
  Because we cannot use the complete RNG as an argument, we first have to make sure that we call the advancing routine of the seeding generator.
  This behavior reduces the statistical performances of the initialization and complicates the interface even more by adding an extra pair of parentheses.

  Another part we have to deal with are fast and easy-to-use distributions for RNGs to at least generate uniform random numbers.
  The current C++ standard supplies different distributions in form of functor templates that use the same algorithm for all generators by templatizing their function operators.
  \[
    \text{\code{std::uniform\_real\_distribution<float> dist\{\}; auto x = dist(rng);}}
  \]
  This API design consists of two major drawbacks.
  The user always has to first construct the object of the according distribution type and afterwards using its function operator to actually get a random number that fulfills the conditions of the distribution.
  Hence, even for simple use cases an API overhead emerges by utilizing random numbers via the STL of C++.
  The second problem is that every RNG has to use the same distribution routine which may not be optimized to work well with a given generator.
  Especially for uniformly distributed random numbers, some generators can exploit the implementation of their transition and generator function to achieve better performance.
  But in C++, we are not able to specialize the function operator template in a distribution functor from the outside.
  The approach does not scale well with the number of different RNGs.

  In the last few years, there has been some development in the area of API design for RNGs.
  \textcite{oneill-blog-api,oneill-blog-rd,cpp-std-seeding,cpp-std-random}, to name a few, provide perfect basic ideas to improve the usage of random utilities in the C++ language.
  We will rely on this work and want to go a step further.
  We strive for a transparent API that can be used easily with different seeding alternatives.
  Nearly every RNG should be available as a source for seeding another RNG.
  In addition, uniform distribution functions will be introduced that do not need to be called as functor objects.
  Through template meta programming, we give generators the possibility of specializing such helper functions through member functions of the same name.
  This idea makes it even possible to specialize these functions outside of the RNG structure for a non-intrusive adjustment.
  Furthermore, by providing those functions we keep compatibility to the standard distributions.


  \inputCodeBlock[title = Is-Valid Utility]{code/is_valid.hpp}
  \inputCodeBlock[title = Uniform Template]{code/uniform.hpp}

  \subsection{C++ Concepts} % (fold)
  \label{sub:c_concepts}

  % subsection c_concepts (end)

  \subsection{Uniform Random Bit Generator} % (fold)
  \label{sub:uniform_random_bit_generator}

  % subsection uniform_random_bit_generator (end)

  \subsection{Random Number Engine} % (fold)
  \label{sub:random_number_engine}

  % subsection random_number_engine (end)

  \subsection{Seeding and Seed Sequences} % (fold)
  \label{sub:seeding_and_seed_sequences}

  % subsection seeding_and_seed_sequences (end)

  \subsection{Distributions} % (fold)
  \label{sub:distributions}

  % subsection distributions (end)

  \subsection{Algorithms} % (fold)
  \label{sub:algorithms}

  % subsection algorithms (end)

  What do we want from the interface of our RNG?
  It should make testing with given frameworks like TestU01, dieharder, ent and PractRand easy.
  Benchmarking should be possible as well.
  Therefore we need a good API and a good application interface.
  Most of the time we want to generate uniform distributed real or integer numbers.
  We need two helper functions.
  So we see that the concept of a distribution makes things complicated.
  We cannot specialize distributions for certain RNGs.
  We cannot use lambda expressions as distributions.
  Therefore we want to use only helper functions as distributions and not member functions.
  So we do not have to specify a specialization and instead use the given standard but we are able to do it.
  Therefore functors and old-distributions are distributions as well and hence we are compatible to the standard.

  Additionally, we have to be more specific about the concept of a random number engine.
  The output of a random number engine of the current concept is magical unsigned integer which should be uniformly distributed in the interval [min,max].
  But these magic numbers can result in certain problems if used the wrong way, see Melissa O'Neill Seeding Surprises.
  Therefore the general idea is to always use the helper functions as new distributions which define min and max explicitly and make sure you really get those values.
  This is also a good idea for the standard.
  And it is compatible with the current standard.

  Now think of vector registers and multiprocessors.
  The random number engine should provide ways to fill a range with random numbers such that it can perform generation more efficiently.
  Think about the execution policies in C++17.
  They should be provided as well.
% section design_of_the_api (end)
\end{document}