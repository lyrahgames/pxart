{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"about/license/","text":"Licensing \u00b6","title":"Licensing"},{"location":"about/license/#licensing","text":"","title":"Licensing"},{"location":"advanced/benchmarks/","text":"Benchmarks \u00b6 Cache Generation \u00b6 Monte Carlo \u03c0 \u00b6","title":"Benchmarks"},{"location":"advanced/benchmarks/#benchmarks","text":"","title":"Benchmarks"},{"location":"advanced/benchmarks/#cache-generation","text":"","title":"Cache Generation"},{"location":"advanced/benchmarks/#monte-carlo","text":"","title":"Monte Carlo \u03c0"},{"location":"advanced/statistical_performance/","text":"Statistical Performance Tests \u00b6 TestU01 \u00b6 Dieharder \u00b6","title":"Statistical Performance Tests"},{"location":"advanced/statistical_performance/#statistical-performance-tests","text":"","title":"Statistical Performance Tests"},{"location":"advanced/statistical_performance/#testu01","text":"","title":"TestU01"},{"location":"advanced/statistical_performance/#dieharder","text":"","title":"Dieharder"},{"location":"advanced/unit_tests/","text":"Unit Tests \u00b6","title":"Unit Tests"},{"location":"advanced/unit_tests/#unit-tests","text":"","title":"Unit Tests"},{"location":"api/overview/","text":"Overview \u00b6 The API documentation shows only the interface of functions and types which are to some extent fixed and are expected to be used from an external project. Everything else will be seen as implementation detail and may be changed frequently. Basic Parts \u00b6 Basic Parts of the pXart API","title":"Overview"},{"location":"api/overview/#overview","text":"The API documentation shows only the interface of functions and types which are to some extent fixed and are expected to be used from an external project. Everything else will be seen as implementation detail and may be changed frequently.","title":"Overview"},{"location":"api/overview/#basic-parts","text":"Basic Parts of the pXart API","title":"Basic Parts"},{"location":"api/algorithms/generate/","text":"Generate \u00b6 template < typename RNG , typename Iterator > constexpr auto pxart :: generate ( RNG && rng , Iterator first , Iterator last ); For all iterated elements rng() is called and used as new value. This function can specialized for other types to provide more efficient implementations. Include Scheme \u00b6 #include <pxart/algorithm.hpp> Example \u00b6 #include <iomanip> #include <iostream> #include <random> #include <vector> // #include <pxart/algorithm.hpp> #include <pxart/mt19937.hpp> #include <pxart/uniform.hpp> using namespace std ; int main () { pxart :: mt19937 rng { random_device {}}; for ( size_t i = 0 ; i < 10 ; ++ i ) { vector < char > letters ( 20 ); // Call generate algorithm to generate random 20-character-wide vector. pxart :: generate ([ & rng ]() { return uniform < char > ( rng , 'a' , 'z' ); }, begin ( letters ), end ( letters )); for ( auto c : letters ) cout << c ; cout << '\\n' ; } }","title":"Generate"},{"location":"api/algorithms/generate/#generate","text":"template < typename RNG , typename Iterator > constexpr auto pxart :: generate ( RNG && rng , Iterator first , Iterator last ); For all iterated elements rng() is called and used as new value. This function can specialized for other types to provide more efficient implementations.","title":"Generate"},{"location":"api/algorithms/generate/#include-scheme","text":"#include <pxart/algorithm.hpp>","title":"Include Scheme"},{"location":"api/algorithms/generate/#example","text":"#include <iomanip> #include <iostream> #include <random> #include <vector> // #include <pxart/algorithm.hpp> #include <pxart/mt19937.hpp> #include <pxart/uniform.hpp> using namespace std ; int main () { pxart :: mt19937 rng { random_device {}}; for ( size_t i = 0 ; i < 10 ; ++ i ) { vector < char > letters ( 20 ); // Call generate algorithm to generate random 20-character-wide vector. pxart :: generate ([ & rng ]() { return uniform < char > ( rng , 'a' , 'z' ); }, begin ( letters ), end ( letters )); for ( auto c : letters ) cout << c ; cout << '\\n' ; } }","title":"Example"},{"location":"api/distributions/uniform/","text":"Uniform Distribution \u00b6 Scalar \u00b6 template < typename T , typename RNG > inline T pxart :: uniform ( RNG && rng ); This functions advances the state of the given random number generator to get a number and transforms it such that a sequence of returned numbers is uniformly distributed in a default type-dependent range. The default range for floating-point types is \\([0,1)\\) . The default range for integral types is every possible integral number that can be stored by the given type. template < typename T , typename RNG > inline T pxart :: uniform ( RNG && rng , T a , T b ) noexcept ; This functions advances the state of the given random number generator to get a number and transforms it such that a sequence of returned numbers is uniformly distributed in the given range. The range for floating-point types is interpreted as \\([a,b)\\) . The range for integral types is interpreted as \\(\\{x\\in\\mathbb{Z} \\ | \\ a\\leq x \\leq b\\}\\) . Include Scheme \u00b6 #include <pxart/uniform.hpp> Floating-Point Numbers \u00b6 The pxart :: uniform methods for floating-point types can only be used for float and double . Notes and Implementation Details \u00b6 Scheme of the Uniform Distribution Implementation for Floating-Point Numbers Example \u00b6 #include <iomanip> #include <iostream> #include <random> // #include <pxart/mt19937.hpp> #include <pxart/uniform.hpp> using namespace std ; int main () { // Initialize pxart PRNG. pxart :: mt19937 rng { random_device {}}; // Print some pseudorandom numbers. for ( size_t i = 0 ; i < 10 ; ++ i ) { // Generate uniformly distributed single-precision floating-point number // in the interval [0, 1). const auto random1 = uniform < float > ( rng ); // Generate uniformly distributed double-precision floating-point number // in the interval [-1.5, 1.0). const auto random2 = uniform ( rng , -1.5 , 1.0 ); cout << setw ( 20 ) << random1 << setw ( 20 ) << random2 << '\\n' ; } } Integral Numbers \u00b6 Notes and Implementation Details \u00b6 To be fast, the pxart::uniform methods for integral numbers exhibit a small bias which is caused by round-off errors when truncating the shifted multiplication of two integral numbers. Example \u00b6 #include <iomanip> #include <iostream> #include <random> // #include <pxart/mt19937.hpp> #include <pxart/uniform.hpp> using namespace std ; int main () { // Initialize pxart PRNG. pxart :: mt19937 rng { random_device {}}; // Print some pseudorandom numbers. for ( size_t i = 0 ; i < 10 ; ++ i ) { // Generate uniformly distributed integral numbers of type int // in the interval [-12, 25]. const auto random1 = uniform < int > ( rng , -12 , 25 ); // Generate uniformly distributed characters // in the interval ['A', 'Z']. const auto random2 = uniform < char > ( rng , 'A' , 'Z' ); cout << setw ( 20 ) << random1 << setw ( 20 ) << random2 << '\\n' ; } }","title":"Uniform Distribution"},{"location":"api/distributions/uniform/#uniform-distribution","text":"","title":"Uniform Distribution"},{"location":"api/distributions/uniform/#scalar","text":"template < typename T , typename RNG > inline T pxart :: uniform ( RNG && rng ); This functions advances the state of the given random number generator to get a number and transforms it such that a sequence of returned numbers is uniformly distributed in a default type-dependent range. The default range for floating-point types is \\([0,1)\\) . The default range for integral types is every possible integral number that can be stored by the given type. template < typename T , typename RNG > inline T pxart :: uniform ( RNG && rng , T a , T b ) noexcept ; This functions advances the state of the given random number generator to get a number and transforms it such that a sequence of returned numbers is uniformly distributed in the given range. The range for floating-point types is interpreted as \\([a,b)\\) . The range for integral types is interpreted as \\(\\{x\\in\\mathbb{Z} \\ | \\ a\\leq x \\leq b\\}\\) .","title":"Scalar"},{"location":"api/distributions/uniform/#include-scheme","text":"#include <pxart/uniform.hpp>","title":"Include Scheme"},{"location":"api/distributions/uniform/#floating-point-numbers","text":"The pxart :: uniform methods for floating-point types can only be used for float and double .","title":"Floating-Point Numbers"},{"location":"api/distributions/uniform/#notes-and-implementation-details","text":"Scheme of the Uniform Distribution Implementation for Floating-Point Numbers","title":"Notes and Implementation Details"},{"location":"api/distributions/uniform/#example","text":"#include <iomanip> #include <iostream> #include <random> // #include <pxart/mt19937.hpp> #include <pxart/uniform.hpp> using namespace std ; int main () { // Initialize pxart PRNG. pxart :: mt19937 rng { random_device {}}; // Print some pseudorandom numbers. for ( size_t i = 0 ; i < 10 ; ++ i ) { // Generate uniformly distributed single-precision floating-point number // in the interval [0, 1). const auto random1 = uniform < float > ( rng ); // Generate uniformly distributed double-precision floating-point number // in the interval [-1.5, 1.0). const auto random2 = uniform ( rng , -1.5 , 1.0 ); cout << setw ( 20 ) << random1 << setw ( 20 ) << random2 << '\\n' ; } }","title":"Example"},{"location":"api/distributions/uniform/#integral-numbers","text":"","title":"Integral Numbers"},{"location":"api/distributions/uniform/#notes-and-implementation-details_1","text":"To be fast, the pxart::uniform methods for integral numbers exhibit a small bias which is caused by round-off errors when truncating the shifted multiplication of two integral numbers.","title":"Notes and Implementation Details"},{"location":"api/distributions/uniform/#example_1","text":"#include <iomanip> #include <iostream> #include <random> // #include <pxart/mt19937.hpp> #include <pxart/uniform.hpp> using namespace std ; int main () { // Initialize pxart PRNG. pxart :: mt19937 rng { random_device {}}; // Print some pseudorandom numbers. for ( size_t i = 0 ; i < 10 ; ++ i ) { // Generate uniformly distributed integral numbers of type int // in the interval [-12, 25]. const auto random1 = uniform < int > ( rng , -12 , 25 ); // Generate uniformly distributed characters // in the interval ['A', 'Z']. const auto random2 = uniform < char > ( rng , 'A' , 'Z' ); cout << setw ( 20 ) << random1 << setw ( 20 ) << random2 << '\\n' ; } }","title":"Example"},{"location":"api/generators/lcg/","text":"Linear Congruential Generator \u00b6 Scalar \u00b6 namespace pxart { template < typename Result_type , typename Uint_type , Uint_type a , Uint_type c , Uint_type m > struct lcg ; using minstd_rand = lcg < uint32_t , uint64_t , 48271 , 0 , 2147483647 > ; } Include Scheme \u00b6 #include <pxart/lcg.hpp> Member Types \u00b6 using uint_type = Uint_type ; using result_type = Result_type ; Member Functions \u00b6 Construction and Seeding \u00b6 constexpr lcg (); Default constructor. constexpr explicit lcg ( uint_type seed ) noexcept ; Initialize the PRNG by using a single seed value. Generation \u00b6 constexpr result_type operator ()() noexcept ; Return pseudorandom numbers and advance the state of the generator. Example \u00b6 #include <iomanip> #include <iostream> #include <random> // #include <pxart/lcg.hpp> #include <pxart/uniform.hpp> using namespace std ; int main () { // Properly initialize pxart PRNG. pxart :: minstd_rand rng { std :: random_device {}()}; // Print some uniformly distributed random numbers. for ( size_t i = 0 ; i < 10 ; ++ i ) cout << setw ( 20 ) << pxart :: uniform < float > ( rng ) << '\\n' ; }","title":"Linear Congruential Generator"},{"location":"api/generators/lcg/#linear-congruential-generator","text":"","title":"Linear Congruential Generator"},{"location":"api/generators/lcg/#scalar","text":"namespace pxart { template < typename Result_type , typename Uint_type , Uint_type a , Uint_type c , Uint_type m > struct lcg ; using minstd_rand = lcg < uint32_t , uint64_t , 48271 , 0 , 2147483647 > ; }","title":"Scalar"},{"location":"api/generators/lcg/#include-scheme","text":"#include <pxart/lcg.hpp>","title":"Include Scheme"},{"location":"api/generators/lcg/#member-types","text":"using uint_type = Uint_type ; using result_type = Result_type ;","title":"Member Types"},{"location":"api/generators/lcg/#member-functions","text":"","title":"Member Functions"},{"location":"api/generators/lcg/#construction-and-seeding","text":"constexpr lcg (); Default constructor. constexpr explicit lcg ( uint_type seed ) noexcept ; Initialize the PRNG by using a single seed value.","title":"Construction and Seeding"},{"location":"api/generators/lcg/#generation","text":"constexpr result_type operator ()() noexcept ; Return pseudorandom numbers and advance the state of the generator.","title":"Generation"},{"location":"api/generators/lcg/#example","text":"#include <iomanip> #include <iostream> #include <random> // #include <pxart/lcg.hpp> #include <pxart/uniform.hpp> using namespace std ; int main () { // Properly initialize pxart PRNG. pxart :: minstd_rand rng { std :: random_device {}()}; // Print some uniformly distributed random numbers. for ( size_t i = 0 ; i < 10 ; ++ i ) cout << setw ( 20 ) << pxart :: uniform < float > ( rng ) << '\\n' ; }","title":"Example"},{"location":"api/generators/msws/","text":"MSWS \u00b6 Abstract Scheme of the MSWS Scalar \u00b6 namespace pxart { struct msws ; } Include Scheme \u00b6 #include <pxart/msws.hpp> Member Types \u00b6 using uint_type = uint64_t ; using result_type = uint32_t ; Member Functions \u00b6 Construction and Seeding \u00b6 constexpr msws (); Default constructor. template < typename RNG > explicit msws ( RNG && rng ); Initialize the PRNG by any other seeder or RNG. Generation \u00b6 constexpr result_type operator ()() noexcept ; Generate next pseudorandom number and advance inner state of the PRNG. constexpr void jump () noexcept ; Advance the inner state by \\(2^{64}\\) elements. constexpr void long_jump () noexcept ; Advance the inner state by \\(2^{96}\\) elements. Characteristics \u00b6 static constexpr result_type min () noexcept ; static constexpr result_type max () noexcept ; Return the output range of pseudorandom numbers. Example \u00b6 #include <iomanip> #include <iostream> #include <random> // #include <pxart/msws.hpp> #include <pxart/uniform.hpp> using namespace std ; int main () { // Properly initialize pxart PRNG. pxart :: msws rng { std :: random_device {}}; // Print some uniformly distributed random numbers. for ( size_t i = 0 ; i < 10 ; ++ i ) cout << setw ( 20 ) << pxart :: uniform < float > ( rng ) << '\\n' ; }","title":"MSWS"},{"location":"api/generators/msws/#msws","text":"Abstract Scheme of the MSWS","title":"MSWS"},{"location":"api/generators/msws/#scalar","text":"namespace pxart { struct msws ; }","title":"Scalar"},{"location":"api/generators/msws/#include-scheme","text":"#include <pxart/msws.hpp>","title":"Include Scheme"},{"location":"api/generators/msws/#member-types","text":"using uint_type = uint64_t ; using result_type = uint32_t ;","title":"Member Types"},{"location":"api/generators/msws/#member-functions","text":"","title":"Member Functions"},{"location":"api/generators/msws/#construction-and-seeding","text":"constexpr msws (); Default constructor. template < typename RNG > explicit msws ( RNG && rng ); Initialize the PRNG by any other seeder or RNG.","title":"Construction and Seeding"},{"location":"api/generators/msws/#generation","text":"constexpr result_type operator ()() noexcept ; Generate next pseudorandom number and advance inner state of the PRNG. constexpr void jump () noexcept ; Advance the inner state by \\(2^{64}\\) elements. constexpr void long_jump () noexcept ; Advance the inner state by \\(2^{96}\\) elements.","title":"Generation"},{"location":"api/generators/msws/#characteristics","text":"static constexpr result_type min () noexcept ; static constexpr result_type max () noexcept ; Return the output range of pseudorandom numbers.","title":"Characteristics"},{"location":"api/generators/msws/#example","text":"#include <iomanip> #include <iostream> #include <random> // #include <pxart/msws.hpp> #include <pxart/uniform.hpp> using namespace std ; int main () { // Properly initialize pxart PRNG. pxart :: msws rng { std :: random_device {}}; // Print some uniformly distributed random numbers. for ( size_t i = 0 ; i < 10 ; ++ i ) cout << setw ( 20 ) << pxart :: uniform < float > ( rng ) << '\\n' ; }","title":"Example"},{"location":"api/generators/mt19937/","text":"MT19937 \u00b6 Abstract Scheme of the MT19937 Scalar \u00b6 namespace pxart { struct mt19937 ; } Include Scheme \u00b6 #include <pxart/mt19937.hpp> Member Types \u00b6 using uint_type = uint32_t ; using result_type = uint_type ; struct default_seeder ; Member Functions \u00b6 Construction and Seeding \u00b6 constexpr mt19937 (); Default constructor which uses a default-initialized pxart::mt19937::default_seeder . template < typename RNG > constexpr explicit mt19937 ( RNG && rng ); Initialize the PRNG by any other seeder or RNG. Generation \u00b6 constexpr result_type operator ()() noexcept ; Return pseudorandom numbers and advance the state of the generator. Characteristics \u00b6 constexpr result_type min () noexcept ; constexpr result_type max () noexcept ; Return the output range of pseudorandom numbers. Notes \u00b6 pxart :: mt19937 used with pxart :: mt19937 :: default_seeder produces exactly the same results as std :: mt19937 from the C++ STL. Example \u00b6 #include <iomanip> #include <iostream> #include <random> // #include <pxart/mt19937.hpp> #include <pxart/uniform.hpp> using namespace std ; int main () { // Properly initialize pxart PRNG. pxart :: mt19937 rng { std :: random_device {}}; // Print some uniformly distributed random numbers. for ( size_t i = 0 ; i < 10 ; ++ i ) cout << setw ( 20 ) << pxart :: uniform < float > ( rng ) << '\\n' ; }","title":"MT19937"},{"location":"api/generators/mt19937/#mt19937","text":"Abstract Scheme of the MT19937","title":"MT19937"},{"location":"api/generators/mt19937/#scalar","text":"namespace pxart { struct mt19937 ; }","title":"Scalar"},{"location":"api/generators/mt19937/#include-scheme","text":"#include <pxart/mt19937.hpp>","title":"Include Scheme"},{"location":"api/generators/mt19937/#member-types","text":"using uint_type = uint32_t ; using result_type = uint_type ; struct default_seeder ;","title":"Member Types"},{"location":"api/generators/mt19937/#member-functions","text":"","title":"Member Functions"},{"location":"api/generators/mt19937/#construction-and-seeding","text":"constexpr mt19937 (); Default constructor which uses a default-initialized pxart::mt19937::default_seeder . template < typename RNG > constexpr explicit mt19937 ( RNG && rng ); Initialize the PRNG by any other seeder or RNG.","title":"Construction and Seeding"},{"location":"api/generators/mt19937/#generation","text":"constexpr result_type operator ()() noexcept ; Return pseudorandom numbers and advance the state of the generator.","title":"Generation"},{"location":"api/generators/mt19937/#characteristics","text":"constexpr result_type min () noexcept ; constexpr result_type max () noexcept ; Return the output range of pseudorandom numbers.","title":"Characteristics"},{"location":"api/generators/mt19937/#notes","text":"pxart :: mt19937 used with pxart :: mt19937 :: default_seeder produces exactly the same results as std :: mt19937 from the C++ STL.","title":"Notes"},{"location":"api/generators/mt19937/#example","text":"#include <iomanip> #include <iostream> #include <random> // #include <pxart/mt19937.hpp> #include <pxart/uniform.hpp> using namespace std ; int main () { // Properly initialize pxart PRNG. pxart :: mt19937 rng { std :: random_device {}}; // Print some uniformly distributed random numbers. for ( size_t i = 0 ; i < 10 ; ++ i ) cout << setw ( 20 ) << pxart :: uniform < float > ( rng ) << '\\n' ; }","title":"Example"},{"location":"api/generators/pcg32/","text":"PCG32 \u00b6 Scalar \u00b6 namespace pxart { struct pcg32 ; } Include Scheme \u00b6 #include <pxart/pcg32.hpp> Member Types \u00b6 using uint_type = uint64_t ; using result_type = uint32_t ; Member Functions \u00b6 Construction and Seeding \u00b6 constexpr pcg32 (); Default constructor. template < typename RNG > constexpr explicit pcg32 ( RNG && rng ); Initialize the PRNG by any other seeder or RNG. Generation \u00b6 constexpr result_type operator ()() noexcept ; Return pseudorandom numbers and advance the state of the generator. Example \u00b6 #include <iomanip> #include <iostream> #include <random> // #include <pxart/pcg32.hpp> #include <pxart/uniform.hpp> using namespace std ; int main () { // Properly initialize pxart PRNG. pxart :: pcg32 rng { std :: random_device {}}; // Print some uniformly distributed random numbers. for ( size_t i = 0 ; i < 10 ; ++ i ) cout << setw ( 20 ) << pxart :: uniform < float > ( rng ) << '\\n' ; }","title":"PCG32"},{"location":"api/generators/pcg32/#pcg32","text":"","title":"PCG32"},{"location":"api/generators/pcg32/#scalar","text":"namespace pxart { struct pcg32 ; }","title":"Scalar"},{"location":"api/generators/pcg32/#include-scheme","text":"#include <pxart/pcg32.hpp>","title":"Include Scheme"},{"location":"api/generators/pcg32/#member-types","text":"using uint_type = uint64_t ; using result_type = uint32_t ;","title":"Member Types"},{"location":"api/generators/pcg32/#member-functions","text":"","title":"Member Functions"},{"location":"api/generators/pcg32/#construction-and-seeding","text":"constexpr pcg32 (); Default constructor. template < typename RNG > constexpr explicit pcg32 ( RNG && rng ); Initialize the PRNG by any other seeder or RNG.","title":"Construction and Seeding"},{"location":"api/generators/pcg32/#generation","text":"constexpr result_type operator ()() noexcept ; Return pseudorandom numbers and advance the state of the generator.","title":"Generation"},{"location":"api/generators/pcg32/#example","text":"#include <iomanip> #include <iostream> #include <random> // #include <pxart/pcg32.hpp> #include <pxart/uniform.hpp> using namespace std ; int main () { // Properly initialize pxart PRNG. pxart :: pcg32 rng { std :: random_device {}}; // Print some uniformly distributed random numbers. for ( size_t i = 0 ; i < 10 ; ++ i ) cout << setw ( 20 ) << pxart :: uniform < float > ( rng ) << '\\n' ; }","title":"Example"},{"location":"api/generators/xoroshiro128%2B/","text":"Xoroshiro128+ \u00b6 Abstract Scheme of the Xoroshiro128+ Scalar \u00b6 namespace pxart { struct xoroshiro128plus ; using xrsr128p = xoroshiro128plus ; } Include Scheme \u00b6 #include <pxart/xoroshiro128plus.hpp> Member Types \u00b6 using uint_type = uint64_t ; using result_type = uint_type ; Member Functions \u00b6 Construction and Seeding \u00b6 xoroshiro128plus (); Default constructor. xoroshiro128plus ( uint_type x , uint_type y ); Parameter constructor. template < typename RNG > constexpr explicit xoroshiro128plus ( RNG && rng ); Initialize the PRNG by any other seeder or RNG. Generation \u00b6 constexpr auto operator ()() noexcept ; Generate next pseudorandom number and advance inner state of the PRNG. constexpr void jump () noexcept ; Advance the inner state by \\(2^{64}\\) elements. constexpr void long_jump () noexcept ; Advance the inner state by \\(2^{96}\\) elements. Characteristics \u00b6 static constexpr auto min () noexcept ; static constexpr auto max () noexcept ; Return the output range of pseudorandom numbers. Example \u00b6 #include <iomanip> #include <iostream> #include <random> // #include <pxart/uniform.hpp> #include <pxart/xoroshiro128plus.hpp> using namespace std ; int main () { // Properly initialize pxart PRNG. pxart :: xrsr128p rng { std :: random_device {}}; // Print some uniformly distributed random numbers. for ( size_t i = 0 ; i < 10 ; ++ i ) cout << setw ( 20 ) << pxart :: uniform < float > ( rng ) << '\\n' ; }","title":"Xoroshiro128+"},{"location":"api/generators/xoroshiro128%2B/#xoroshiro128","text":"Abstract Scheme of the Xoroshiro128+","title":"Xoroshiro128+"},{"location":"api/generators/xoroshiro128%2B/#scalar","text":"namespace pxart { struct xoroshiro128plus ; using xrsr128p = xoroshiro128plus ; }","title":"Scalar"},{"location":"api/generators/xoroshiro128%2B/#include-scheme","text":"#include <pxart/xoroshiro128plus.hpp>","title":"Include Scheme"},{"location":"api/generators/xoroshiro128%2B/#member-types","text":"using uint_type = uint64_t ; using result_type = uint_type ;","title":"Member Types"},{"location":"api/generators/xoroshiro128%2B/#member-functions","text":"","title":"Member Functions"},{"location":"api/generators/xoroshiro128%2B/#construction-and-seeding","text":"xoroshiro128plus (); Default constructor. xoroshiro128plus ( uint_type x , uint_type y ); Parameter constructor. template < typename RNG > constexpr explicit xoroshiro128plus ( RNG && rng ); Initialize the PRNG by any other seeder or RNG.","title":"Construction and Seeding"},{"location":"api/generators/xoroshiro128%2B/#generation","text":"constexpr auto operator ()() noexcept ; Generate next pseudorandom number and advance inner state of the PRNG. constexpr void jump () noexcept ; Advance the inner state by \\(2^{64}\\) elements. constexpr void long_jump () noexcept ; Advance the inner state by \\(2^{96}\\) elements.","title":"Generation"},{"location":"api/generators/xoroshiro128%2B/#characteristics","text":"static constexpr auto min () noexcept ; static constexpr auto max () noexcept ; Return the output range of pseudorandom numbers.","title":"Characteristics"},{"location":"api/generators/xoroshiro128%2B/#example","text":"#include <iomanip> #include <iostream> #include <random> // #include <pxart/uniform.hpp> #include <pxart/xoroshiro128plus.hpp> using namespace std ; int main () { // Properly initialize pxart PRNG. pxart :: xrsr128p rng { std :: random_device {}}; // Print some uniformly distributed random numbers. for ( size_t i = 0 ; i < 10 ; ++ i ) cout << setw ( 20 ) << pxart :: uniform < float > ( rng ) << '\\n' ; }","title":"Example"},{"location":"api/seeding/mt19937_default_seeder/","text":"MT19937 Default Seeder \u00b6 The purpose of pxart :: mt19937 :: default_seeder is to provide reasonable pseudorandom seeds based on a single truly or fixed seed value. It is implemented in such a way that pxart::mt19937 outputs the same values in the same order as std::mt19937 when pxart::mt19937::default_seeder is initialized with the same integer value than std::mt19937 . Note We do not recommend to use pxart :: mt19937 :: default_seeder because it only uses a single seed value. Hence, we designed the interface to be a little bit more complicated to emphasize the seeding mechanism. It is implemented for the sake of completeness. Instead you should use pxart :: seed_seq . namespace pxart { struct mt19937 :: default_seeder ; } Include Scheme \u00b6 #include <pxart/mt19937.hpp> Member Functions \u00b6 Construction \u00b6 constexpr default_seeder (); Default constructor uses a default seed value and the one-parameter constructor. constexpr explicit default_seeder ( uint_type s ); Initializes the object by a single given integer. Generation \u00b6 constexpr uint_type operator ()() noexcept ; Generates reasonable pseudorandom seed values for the MT19937 based on a single fixed value or a single truly random seed. Characteristics \u00b6 constexpr uint_type min () noexcept ; constexpr uint_type max () noexcept ; These functions return the output range of the seeder. Example \u00b6 #include <iomanip> #include <iostream> #include <random> // #include <pxart/mt19937.hpp> using namespace std ; int main () { // Best case: Generate truly random seed. const auto seed = std :: random_device {}(); // Generate std PRNG to compare against. std :: mt19937 std_rng { seed }; // Generate pxart PRNG with the default seeder and the same seed. pxart :: mt19937 :: default_seeder seeder { seed }; pxart :: mt19937 rng { seeder }; // Print some pseudorandom numbers of the standard generator and the pxart // generator to compare them and show that they are equal. for ( size_t i = 0 ; i < 10 ; ++ i ) cout << setw ( 20 ) << std_rng () << setw ( 20 ) << rng () << '\\n' ; }","title":"MT19937 Default Seeder"},{"location":"api/seeding/mt19937_default_seeder/#mt19937-default-seeder","text":"The purpose of pxart :: mt19937 :: default_seeder is to provide reasonable pseudorandom seeds based on a single truly or fixed seed value. It is implemented in such a way that pxart::mt19937 outputs the same values in the same order as std::mt19937 when pxart::mt19937::default_seeder is initialized with the same integer value than std::mt19937 . Note We do not recommend to use pxart :: mt19937 :: default_seeder because it only uses a single seed value. Hence, we designed the interface to be a little bit more complicated to emphasize the seeding mechanism. It is implemented for the sake of completeness. Instead you should use pxart :: seed_seq . namespace pxart { struct mt19937 :: default_seeder ; }","title":"MT19937 Default Seeder"},{"location":"api/seeding/mt19937_default_seeder/#include-scheme","text":"#include <pxart/mt19937.hpp>","title":"Include Scheme"},{"location":"api/seeding/mt19937_default_seeder/#member-functions","text":"","title":"Member Functions"},{"location":"api/seeding/mt19937_default_seeder/#construction","text":"constexpr default_seeder (); Default constructor uses a default seed value and the one-parameter constructor. constexpr explicit default_seeder ( uint_type s ); Initializes the object by a single given integer.","title":"Construction"},{"location":"api/seeding/mt19937_default_seeder/#generation","text":"constexpr uint_type operator ()() noexcept ; Generates reasonable pseudorandom seed values for the MT19937 based on a single fixed value or a single truly random seed.","title":"Generation"},{"location":"api/seeding/mt19937_default_seeder/#characteristics","text":"constexpr uint_type min () noexcept ; constexpr uint_type max () noexcept ; These functions return the output range of the seeder.","title":"Characteristics"},{"location":"api/seeding/mt19937_default_seeder/#example","text":"#include <iomanip> #include <iostream> #include <random> // #include <pxart/mt19937.hpp> using namespace std ; int main () { // Best case: Generate truly random seed. const auto seed = std :: random_device {}(); // Generate std PRNG to compare against. std :: mt19937 std_rng { seed }; // Generate pxart PRNG with the default seeder and the same seed. pxart :: mt19937 :: default_seeder seeder { seed }; pxart :: mt19937 rng { seeder }; // Print some pseudorandom numbers of the standard generator and the pxart // generator to compare them and show that they are equal. for ( size_t i = 0 ; i < 10 ; ++ i ) cout << setw ( 20 ) << std_rng () << setw ( 20 ) << rng () << '\\n' ; }","title":"Example"},{"location":"api/seeding/random_device/","text":"Random Device \u00b6 The C++ STL provides std::random_device as a default seeding structure. For a lot of platforms, std::random_device returns truly random numbers and should be used for proper seeding of other PRNGs. Some are only providing deterministic behavior. So an alternative seeding strategy should be used for such platforms. Example \u00b6 #include <iomanip> #include <iostream> #include <random> // #include <pxart/mt19937.hpp> using namespace std ; int main () { // Create pxart PRNG and seed it by using std::random_device. pxart :: mt19937 rng { std :: random_device {}}; // Print some random numbers. for ( size_t i = 0 ; i < 10 ; ++ i ) cout << setw ( 20 ) << rng () << '\\n' ; }","title":"Random Device"},{"location":"api/seeding/random_device/#random-device","text":"The C++ STL provides std::random_device as a default seeding structure. For a lot of platforms, std::random_device returns truly random numbers and should be used for proper seeding of other PRNGs. Some are only providing deterministic behavior. So an alternative seeding strategy should be used for such platforms.","title":"Random Device"},{"location":"api/seeding/random_device/#example","text":"#include <iomanip> #include <iostream> #include <random> // #include <pxart/mt19937.hpp> using namespace std ; int main () { // Create pxart PRNG and seed it by using std::random_device. pxart :: mt19937 rng { std :: random_device {}}; // Print some random numbers. for ( size_t i = 0 ; i < 10 ; ++ i ) cout << setw ( 20 ) << rng () << '\\n' ; }","title":"Example"},{"location":"api/seeding/seed_sequence/","text":"Seed Sequence \u00b6 The goal of seed_seq is to generate reasonable seed data based on multiple entropy arguments or multiple fixed seeds. It is an alternative implementation of M. E. O'Neill's seed_seq Alternative . Take a look at her website to find out how it is working. seed_seq is a k-to-1 mapping and has good avalanche properties. In general, it provides much better behavior than std::seed_seq . We recommend to use seed_seq when possible. Scalar \u00b6 namespace pxart { template < typename T , size_t N > struct seed_seq ; using seed_seq_4x32 = seed_seq < uint32_t , 4 > ; using seed_seq_8x32 = seed_seq < uint32_t , 8 > ; using seed_seq_4x64 = seed_seq < uint64_t , 4 > ; } Include Scheme \u00b6 #include <pxart/seed_seq.hpp> Member Types and Type Variables \u00b6 using uint_type = T ; using result_type = uint_type ; static constexpr size_t state_size = N ; Member Functions \u00b6 Construction \u00b6 constexpr seed_seq () noexcept ; Default construction of pxart :: seed_seq . Calls other constructor with std :: initializer_list and argument { 1 , 2 , 3 , 4 } . template < typename U > seed_seq ( std :: initializer_list < U > init ) noexcept ; Constructor for multiple entropy sources or multiple fixed seed values. This constructor calls the constructor based on input iterators. template < typename InputIt > seed_seq ( InputIt begin , InputIt end ) noexcept ; Constructor generates the state of the object by first hashing the input values and then mixing them by applying another hash and mixing function. If the given number of values is smaller than the actual state then the given entropy will be stretched to all state values. Generation \u00b6 constexpr result_type operator ()() noexcept ; Returns a pseudorandom number based on the current state of the object. This function is used to seed other PRNGs in a reasonable way. Example \u00b6 #include <iomanip> #include <iostream> // #include <pxart/mt19937.hpp> #include <pxart/seed_seq.hpp> using namespace std ; int main () { // Construct PRNG by seeding it with seed_seq_8x32 which itself uses four // fixed seed values. pxart :: seed_seq_8x32 seeder { 1 , 2 , 3 , 4 }; pxart :: mt19937 rng { seeder }; // Return some pseudorandom numbers. for ( int i = 0 ; i < 10 ; ++ i ) cout << setw ( 15 ) << rng () << '\\n' ; }","title":"Seed Sequence"},{"location":"api/seeding/seed_sequence/#seed-sequence","text":"The goal of seed_seq is to generate reasonable seed data based on multiple entropy arguments or multiple fixed seeds. It is an alternative implementation of M. E. O'Neill's seed_seq Alternative . Take a look at her website to find out how it is working. seed_seq is a k-to-1 mapping and has good avalanche properties. In general, it provides much better behavior than std::seed_seq . We recommend to use seed_seq when possible.","title":"Seed Sequence"},{"location":"api/seeding/seed_sequence/#scalar","text":"namespace pxart { template < typename T , size_t N > struct seed_seq ; using seed_seq_4x32 = seed_seq < uint32_t , 4 > ; using seed_seq_8x32 = seed_seq < uint32_t , 8 > ; using seed_seq_4x64 = seed_seq < uint64_t , 4 > ; }","title":"Scalar"},{"location":"api/seeding/seed_sequence/#include-scheme","text":"#include <pxart/seed_seq.hpp>","title":"Include Scheme"},{"location":"api/seeding/seed_sequence/#member-types-and-type-variables","text":"using uint_type = T ; using result_type = uint_type ; static constexpr size_t state_size = N ;","title":"Member Types and Type Variables"},{"location":"api/seeding/seed_sequence/#member-functions","text":"","title":"Member Functions"},{"location":"api/seeding/seed_sequence/#construction","text":"constexpr seed_seq () noexcept ; Default construction of pxart :: seed_seq . Calls other constructor with std :: initializer_list and argument { 1 , 2 , 3 , 4 } . template < typename U > seed_seq ( std :: initializer_list < U > init ) noexcept ; Constructor for multiple entropy sources or multiple fixed seed values. This constructor calls the constructor based on input iterators. template < typename InputIt > seed_seq ( InputIt begin , InputIt end ) noexcept ; Constructor generates the state of the object by first hashing the input values and then mixing them by applying another hash and mixing function. If the given number of values is smaller than the actual state then the given entropy will be stretched to all state values.","title":"Construction"},{"location":"api/seeding/seed_sequence/#generation","text":"constexpr result_type operator ()() noexcept ; Returns a pseudorandom number based on the current state of the object. This function is used to seed other PRNGs in a reasonable way.","title":"Generation"},{"location":"api/seeding/seed_sequence/#example","text":"#include <iomanip> #include <iostream> // #include <pxart/mt19937.hpp> #include <pxart/seed_seq.hpp> using namespace std ; int main () { // Construct PRNG by seeding it with seed_seq_8x32 which itself uses four // fixed seed values. pxart :: seed_seq_8x32 seeder { 1 , 2 , 3 , 4 }; pxart :: mt19937 rng { seeder }; // Return some pseudorandom numbers. for ( int i = 0 ; i < 10 ; ++ i ) cout << setw ( 15 ) << rng () << '\\n' ; }","title":"Example"},{"location":"api/utilities/is_valid/","text":"Is Valid \u00b6","title":"Is Valid"},{"location":"api/utilities/is_valid/#is-valid","text":"","title":"Is Valid"},{"location":"api/utilities/pun_cast/","text":"Type Punning with Pun Cast \u00b6 template < typename T , typename U > T pxart :: pun_cast ( U x ); Reinterprets object of type U as object of type T with the same bit representation. T and U need to have the same size. This function adheres to the strict-aliasing rules. Typically, such type punning is done to reinterpret floating-point types as unsigned integers to manipulate their sign bit and compute the absolute value for example. Here, pun_cast can also be used to reinterpret an SIMD type as an arbitray vector type to be able to access single elements. Include Scheme \u00b6 #include <pxart/utility/pun_cast.hpp> Complexity \u00b6 Constant time complexity. The function should result in only one processor instruction but uses std :: memcpy to not violate the strict-aliasing rules. Exceptions \u00b6 The function itself throws no exceptions. But the inner call to std::memcpy could throw. Example \u00b6 #include <array> #include <cstdint> #include <iomanip> #include <iostream> #include <random> // #include <pxart/simd256/mt19937.hpp> #include <pxart/utility/pun_cast.hpp> using namespace std ; int main () { // Define standard random number generator for comparisons. std :: mt19937 rng {}; // Define PRNG which uses 256-bit vector registers as output. pxart :: simd256 :: mt19937 vrng {}; using uint_type = decltype ( vrng ) :: uint_type ; constexpr size_t simd_size = decltype ( vrng ) :: simd_size ; constexpr size_t n = 10 ; for ( int i = 0 ; i < n ; i += simd_size ) { // Generate random 256-bit vector and reinterpret it as 8-dimensional array // of 32-bit unsigned integers. const auto vrnd = pxart :: pun_cast < array < uint_type , simd_size >> ( vrng ()); // Output generated random numbers. for ( int j = 0 ; j < simd_size ; ++ j ) { const auto rnd = rng (); cout << setw ( 20 ) << rnd << setw ( 20 ) << vrnd [ j ] << '\\n' ; } } }","title":"Type Punning with Pun Cast"},{"location":"api/utilities/pun_cast/#type-punning-with-pun-cast","text":"template < typename T , typename U > T pxart :: pun_cast ( U x ); Reinterprets object of type U as object of type T with the same bit representation. T and U need to have the same size. This function adheres to the strict-aliasing rules. Typically, such type punning is done to reinterpret floating-point types as unsigned integers to manipulate their sign bit and compute the absolute value for example. Here, pun_cast can also be used to reinterpret an SIMD type as an arbitray vector type to be able to access single elements.","title":"Type Punning with Pun Cast"},{"location":"api/utilities/pun_cast/#include-scheme","text":"#include <pxart/utility/pun_cast.hpp>","title":"Include Scheme"},{"location":"api/utilities/pun_cast/#complexity","text":"Constant time complexity. The function should result in only one processor instruction but uses std :: memcpy to not violate the strict-aliasing rules.","title":"Complexity"},{"location":"api/utilities/pun_cast/#exceptions","text":"The function itself throws no exceptions. But the inner call to std::memcpy could throw.","title":"Exceptions"},{"location":"api/utilities/pun_cast/#example","text":"#include <array> #include <cstdint> #include <iomanip> #include <iostream> #include <random> // #include <pxart/simd256/mt19937.hpp> #include <pxart/utility/pun_cast.hpp> using namespace std ; int main () { // Define standard random number generator for comparisons. std :: mt19937 rng {}; // Define PRNG which uses 256-bit vector registers as output. pxart :: simd256 :: mt19937 vrng {}; using uint_type = decltype ( vrng ) :: uint_type ; constexpr size_t simd_size = decltype ( vrng ) :: simd_size ; constexpr size_t n = 10 ; for ( int i = 0 ; i < n ; i += simd_size ) { // Generate random 256-bit vector and reinterpret it as 8-dimensional array // of 32-bit unsigned integers. const auto vrnd = pxart :: pun_cast < array < uint_type , simd_size >> ( vrng ()); // Output generated random numbers. for ( int j = 0 ; j < simd_size ; ++ j ) { const auto rnd = rng (); cout << setw ( 20 ) << rnd << setw ( 20 ) << vrnd [ j ] << '\\n' ; } } }","title":"Example"},{"location":"basics/examples/","text":"Examples \u00b6 Scalar Monte Carlo \u03c0 \u00b6 #include <iostream> // #include <pxart/pxart.hpp> int main (){ constexpr int samples = 100'000'000 ; int result = 0 ; pxart :: mt19937 rng {}; for ( auto i = samples ; i > 0 ; -- i ){ const auto x = pxart :: uniform < float > ( rng ); const auto y = pxart :: uniform < float > ( rng ); result += ( x * x + y * y <= 1 ); } std :: cout << \"pi = \" << 4.0f * result / samples << \" \\n \" ; } AVX2 Monte Carlo \u03c0 \u00b6 The following code has to be compiled with AVX2 support. For GCC and Clang, the easiest method may be to use compilation flags -O3 and -march=native . #include <iostream> // #include <pxart/pxart.hpp> int main () { const int samples = 10'000'000 ; pxart :: simd256 :: mt19937 rng {}; // Initialize vectorized buffer to count the samples that lie inside the // circle for every component. auto samples_in_circle = _mm256_setzero_si256 (); // Iterate over all samples by using the length of the SIMD register. for ( auto i = samples ; i > 0 ; i -= 8 ) { // Generate vectorized samples by using pxart. const auto x = pxart :: simd256 :: uniform < float > ( rng ); const auto y = pxart :: simd256 :: uniform < float > ( rng ); // Test if samples lie inside the circle. const auto radius = _mm256_add_ps ( _mm256_mul_ps ( x , x ), _mm256_mul_ps ( y , y )); const auto mask = _mm256_castps_si256 ( _mm256_cmp_ps ( radius , _mm256_set1_ps ( 1.0f ), _CMP_LE_OQ )); // Add mask to the samples inside the circle for every component. samples_in_circle = _mm256_add_epi32 ( samples_in_circle , _mm256_and_si256 ( _mm256_set1_epi32 ( 1 ), mask )); } // Sum up all components and scale to estimate pi. samples_in_circle = _mm256_hadd_epi32 ( samples_in_circle , samples_in_circle ); samples_in_circle = _mm256_hadd_epi32 ( samples_in_circle , samples_in_circle ); const auto pi = 4.0f * ( reinterpret_cast < uint32_t *> ( & samples_in_circle )[ 0 ] + reinterpret_cast < uint32_t *> ( & samples_in_circle )[ 4 ]) / samples ; std :: cout << \"pi = \" << pi << '\\n' ; }","title":"Examples"},{"location":"basics/examples/#examples","text":"","title":"Examples"},{"location":"basics/examples/#scalar-monte-carlo","text":"#include <iostream> // #include <pxart/pxart.hpp> int main (){ constexpr int samples = 100'000'000 ; int result = 0 ; pxart :: mt19937 rng {}; for ( auto i = samples ; i > 0 ; -- i ){ const auto x = pxart :: uniform < float > ( rng ); const auto y = pxart :: uniform < float > ( rng ); result += ( x * x + y * y <= 1 ); } std :: cout << \"pi = \" << 4.0f * result / samples << \" \\n \" ; }","title":"Scalar Monte Carlo \u03c0"},{"location":"basics/examples/#avx2-monte-carlo","text":"The following code has to be compiled with AVX2 support. For GCC and Clang, the easiest method may be to use compilation flags -O3 and -march=native . #include <iostream> // #include <pxart/pxart.hpp> int main () { const int samples = 10'000'000 ; pxart :: simd256 :: mt19937 rng {}; // Initialize vectorized buffer to count the samples that lie inside the // circle for every component. auto samples_in_circle = _mm256_setzero_si256 (); // Iterate over all samples by using the length of the SIMD register. for ( auto i = samples ; i > 0 ; i -= 8 ) { // Generate vectorized samples by using pxart. const auto x = pxart :: simd256 :: uniform < float > ( rng ); const auto y = pxart :: simd256 :: uniform < float > ( rng ); // Test if samples lie inside the circle. const auto radius = _mm256_add_ps ( _mm256_mul_ps ( x , x ), _mm256_mul_ps ( y , y )); const auto mask = _mm256_castps_si256 ( _mm256_cmp_ps ( radius , _mm256_set1_ps ( 1.0f ), _CMP_LE_OQ )); // Add mask to the samples inside the circle for every component. samples_in_circle = _mm256_add_epi32 ( samples_in_circle , _mm256_and_si256 ( _mm256_set1_epi32 ( 1 ), mask )); } // Sum up all components and scale to estimate pi. samples_in_circle = _mm256_hadd_epi32 ( samples_in_circle , samples_in_circle ); samples_in_circle = _mm256_hadd_epi32 ( samples_in_circle , samples_in_circle ); const auto pi = 4.0f * ( reinterpret_cast < uint32_t *> ( & samples_in_circle )[ 0 ] + reinterpret_cast < uint32_t *> ( & samples_in_circle )[ 4 ]) / samples ; std :: cout << \"pi = \" << pi << '\\n' ; }","title":"AVX2 Monte Carlo \u03c0"},{"location":"basics/quickstart/","text":"Quickstart \u00b6 To use pXart, you have to make two decisions. Which build system will be used to make pXart available to your current project? Which build system will be used for your own project? We explicitly support the installation of pXart by using build2 or CMake. But because it is a header-only library, other build systems should work as well. pXart's Hello-World Example: Monte Carlo \u03c0 \u00b6 #include <iostream> // #include <pxart/pxart.hpp> int main (){ // Construct pxart's scalar MT19937. pxart :: mt19937 rng {}; // Start Monte Carlo computation of \u03c0. constexpr int samples = 100'000'000 ; int result = 0 ; for ( auto i = samples ; i > 0 ; -- i ){ // Let pxart generate uniformly distributed numbers. const auto x = pxart :: uniform < float > ( rng ); const auto y = pxart :: uniform < float > ( rng ); // Test if sample lies inside the circle. result += ( x * x + y * y <= 1 ); } std :: cout << \"pi = \" << 4.0f * result / samples << \" \\n \" ; }","title":"Quickstart"},{"location":"basics/quickstart/#quickstart","text":"To use pXart, you have to make two decisions. Which build system will be used to make pXart available to your current project? Which build system will be used for your own project? We explicitly support the installation of pXart by using build2 or CMake. But because it is a header-only library, other build systems should work as well.","title":"Quickstart"},{"location":"basics/quickstart/#pxarts-hello-world-example-monte-carlo","text":"#include <iostream> // #include <pxart/pxart.hpp> int main (){ // Construct pxart's scalar MT19937. pxart :: mt19937 rng {}; // Start Monte Carlo computation of \u03c0. constexpr int samples = 100'000'000 ; int result = 0 ; for ( auto i = samples ; i > 0 ; -- i ){ // Let pxart generate uniformly distributed numbers. const auto x = pxart :: uniform < float > ( rng ); const auto y = pxart :: uniform < float > ( rng ); // Test if sample lies inside the circle. result += ( x * x + y * y <= 1 ); } std :: cout << \"pi = \" << 4.0f * result / samples << \" \\n \" ; }","title":"pXart's Hello-World Example: Monte Carlo \u03c0"},{"location":"basics/setup_alternative/","text":"Alternative Setup by Inlining \u00b6 pXart explicitly supports build2 and CMake. If you would like to use another build system or no build system at all, you will need to directly set a standard include path for the pXart library by using the specific compiler flags. Project Inlining for build2/CMake Projects and Projects without Build Systems Go into your project folder. Optionally, go into the specific folder of your project for external source code. Copy the folder pxart/pxart of the git repository into the current directory. If you are using no build system, make sure to add the current directory to the standard include paths of your compiler by using a flag. In CMake, you can do this by using include_directories or target_include_directories . In build2, use the configuration variable cxx.poptions in your buildfile and add the specific include flag.","title":"Alternative Setup by Inlining"},{"location":"basics/setup_alternative/#alternative-setup-by-inlining","text":"pXart explicitly supports build2 and CMake. If you would like to use another build system or no build system at all, you will need to directly set a standard include path for the pXart library by using the specific compiler flags. Project Inlining for build2/CMake Projects and Projects without Build Systems Go into your project folder. Optionally, go into the specific folder of your project for external source code. Copy the folder pxart/pxart of the git repository into the current directory. If you are using no build system, make sure to add the current directory to the standard include paths of your compiler by using a flag. In CMake, you can do this by using include_directories or target_include_directories . In build2, use the configuration variable cxx.poptions in your buildfile and add the specific include flag.","title":"Alternative Setup by Inlining"},{"location":"basics/setup_build2/","text":"Note You only have to choose one of the following variants. We suggest to take the first alternative. Alternative 1: build2 Package Dependency for build2 Projects \u00b6 Add the following entry to the repositories.manifest file of your build2 package. : role: prerequisite location: https://github.com/lyrahgames/pxart.git Instead of the GitHub repository you can also use the official pkg.cppget.org package repositories. There you could also add a trusted key if needed. : role: prerequisite location: https://pkg.cppget.org/1/alpha Furthermore, add the following dependency entry to the manifest file. Here, you are allowed to specify the version range. depends: pxart ^0.1.0 Now, import the library in the according buildfile and link it to your target by putting it in the prerequisites. import pxart_lib = pxart%lib{pxart} # ... exe{your_exe}: {hxx cxx}{**} $pxart_lib Alternative 2: build2 Package Installation for build2 Projects and Projects without Build System \u00b6 Create a build2 configuration for packages if it does not exist already. Define a valid installation path which can be found by the compiler. Use specific options, such as to state the compiler with its flags, if necessary. bpkg -d build2-packages cc \\ config.install.root=/usr/local \\ config.install.sudo=sudo Get the latest package release and build it. bpkg build https://github.com/lyrahgames/pxart.git Install the built package. bpkg install pxart For uninstalling, do the following. bpkg uninstall pxart Because the library consists only of header files, the following can be omitted. But it is recommended to do it otherwise, such that all dependencies are stated explicitly. In the appropriate buildfile , import the library by the following code and put the variable into the prerequisites of your target. import pxart_lib = pxart%lib{pxart} If you are using a manifest file, you can state pxart as a requirement. So build2 will try to find the appropriate pkg-config file in the standard paths when importing pxart in a buildfile. requires: pxart Alternatively, if your package uses an explicit depends: pxart make sure to initialize this dependency as a system dependency when creating a new configuration. bdep init -C @build cc config.cxx=g++ \"config.cxx.coptions=-O3\" -- \"?sys:pxart/*\"","title":"Setup with build2"},{"location":"basics/setup_build2/#alternative-1-build2-package-dependency-for-build2-projects","text":"Add the following entry to the repositories.manifest file of your build2 package. : role: prerequisite location: https://github.com/lyrahgames/pxart.git Instead of the GitHub repository you can also use the official pkg.cppget.org package repositories. There you could also add a trusted key if needed. : role: prerequisite location: https://pkg.cppget.org/1/alpha Furthermore, add the following dependency entry to the manifest file. Here, you are allowed to specify the version range. depends: pxart ^0.1.0 Now, import the library in the according buildfile and link it to your target by putting it in the prerequisites. import pxart_lib = pxart%lib{pxart} # ... exe{your_exe}: {hxx cxx}{**} $pxart_lib","title":"Alternative 1: build2 Package Dependency for build2 Projects"},{"location":"basics/setup_build2/#alternative-2-build2-package-installation-for-build2-projects-and-projects-without-build-system","text":"Create a build2 configuration for packages if it does not exist already. Define a valid installation path which can be found by the compiler. Use specific options, such as to state the compiler with its flags, if necessary. bpkg -d build2-packages cc \\ config.install.root=/usr/local \\ config.install.sudo=sudo Get the latest package release and build it. bpkg build https://github.com/lyrahgames/pxart.git Install the built package. bpkg install pxart For uninstalling, do the following. bpkg uninstall pxart Because the library consists only of header files, the following can be omitted. But it is recommended to do it otherwise, such that all dependencies are stated explicitly. In the appropriate buildfile , import the library by the following code and put the variable into the prerequisites of your target. import pxart_lib = pxart%lib{pxart} If you are using a manifest file, you can state pxart as a requirement. So build2 will try to find the appropriate pkg-config file in the standard paths when importing pxart in a buildfile. requires: pxart Alternatively, if your package uses an explicit depends: pxart make sure to initialize this dependency as a system dependency when creating a new configuration. bdep init -C @build cc config.cxx=g++ \"config.cxx.coptions=-O3\" -- \"?sys:pxart/*\"","title":"Alternative 2: build2 Package Installation for build2 Projects and Projects without Build System"},{"location":"basics/setup_cmake/","text":"Note You only have to choose one of the following variants. We suggest to take the first alternative. Alternative 1: CMake Package Installation for CMake Projects and Projects without Build System \u00b6 Download the repository and create a configuration. git clone https://github.com/lyrahgames/pxart.git mkdir pxart-cmake-build cd pxart-cmake-build cmake ../pxart Optionally, build and run the tests. cmake --build . ctest --verbose Install the library and the CMake package. sudo cmake --build . --target install To uninstall the library do the following. sudo cmake --build . --target uninstall Because the library consists only of header files, the following can be omitted. But it is recommended to do it otherwise, such that all dependencies are stated explicitly. In the appropriate CMakeLists.txt file, use find_package(pxart) to find the library and link with the imported target pxart::pxart by using target_link_libraries . The following code shows an example. find_package ( pxart REQUIRED ) add_executable ( main main.cpp ) target_link_libraries ( main PRIVATE pxart::pxart ) Alternative 2: CMake Package Export from Build Configuration for CMake Projects \u00b6 Download the repository and create a configuration. git clone https://github.com/lyrahgames/pxart.git mkdir pxart-cmake-build cd pxart-cmake-build cmake ../pxart Through the standard CMake package export you can externally use the library from the build tree. In the appropriate CMakeLists.txt file, use find_package(pxart) to find the library and link with the imported target pxart::pxart by using target_link_libraries . The following code shows an example. find_package ( pxart REQUIRED ) add_executable ( main main.cpp ) target_link_libraries ( main PRIVATE pxart::pxart )","title":"Setup with CMake"},{"location":"basics/setup_cmake/#alternative-1-cmake-package-installation-for-cmake-projects-and-projects-without-build-system","text":"Download the repository and create a configuration. git clone https://github.com/lyrahgames/pxart.git mkdir pxart-cmake-build cd pxart-cmake-build cmake ../pxart Optionally, build and run the tests. cmake --build . ctest --verbose Install the library and the CMake package. sudo cmake --build . --target install To uninstall the library do the following. sudo cmake --build . --target uninstall Because the library consists only of header files, the following can be omitted. But it is recommended to do it otherwise, such that all dependencies are stated explicitly. In the appropriate CMakeLists.txt file, use find_package(pxart) to find the library and link with the imported target pxart::pxart by using target_link_libraries . The following code shows an example. find_package ( pxart REQUIRED ) add_executable ( main main.cpp ) target_link_libraries ( main PRIVATE pxart::pxart )","title":"Alternative 1: CMake Package Installation for CMake Projects and Projects without Build System"},{"location":"basics/setup_cmake/#alternative-2-cmake-package-export-from-build-configuration-for-cmake-projects","text":"Download the repository and create a configuration. git clone https://github.com/lyrahgames/pxart.git mkdir pxart-cmake-build cd pxart-cmake-build cmake ../pxart Through the standard CMake package export you can externally use the library from the build tree. In the appropriate CMakeLists.txt file, use find_package(pxart) to find the library and link with the imported target pxart::pxart by using target_link_libraries . The following code shows an example. find_package ( pxart REQUIRED ) add_executable ( main main.cpp ) target_link_libraries ( main PRIVATE pxart::pxart )","title":"Alternative 2: CMake Package Export from Build Configuration for CMake Projects"},{"location":"development/setup/","text":"Setup \u00b6 Clone, Initialize, and Build \u00b6 By using build2, pxart can be easily tested with multiple configurations. For this, create a new folder pxart in your favorite project folder, like ~/projects . mkdir pxart We call this one the developer folder, because it will contain the actual Git repository of the code as well as all the configurations the tests will be built for. Go into this folder and clone this repository. cd pxart git clone https://github.com/lyrahgames/pxart We call this one the repository folder, the source folder, or the project folder. Change the directory into the source folder and create all the configurations that you would like to test for. In this example, we will create two configurations for the default GCC and Clang compiler with maximal optimization enabled. cd pxart bdep init -C @gcc cc config.cxx=g++ \"config.cxx.coptions=-03 -march=native\" config.install.root=../install bdep init -C @clang cc config.cxx=clang++ \"config.cxx.coptions=-03 -march=native\" These commands have create two configurations, namely @gcc and @clang , with their respective folders pxart-gcc and pxart-clang in the developer folder. The configuration @gcc is the default configuration and we have enabled local installation support for the folder named install inside the developer folder to be able to test the installation process. The folder structure should now look like the following. pxart/ # Developer Folder \u2502 \u251c\u2500\u2500 pxart/... # Project Folder \u2502 \u251c\u2500\u2500 pxart-gcc/... # Configuration Folder 'gcc' \u2502 \u2514\u2500\u2500 pxart-clang/... # Configuration Folder 'clang' To build all the packages of the project for all initialized configurations, run the following command. bdep update -a Furthermore, we would like to create symbolic links to the executable for the default configuration. For this, we have to run the build system of build2 directly. b To test the installation run the build system with the appropriate target. b install Your developer folder should now contain a folder, called install , with all installed packages. To only have a look at the library installation itself, uninstall all files and go into the library package inside the project folder and run the installation command again. b uninstall cd pxart b install The folder structure of install should look similar to the following. install/ \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 pxart/... # pXart Header Files \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 pkgconfig \u2502 \u251c\u2500\u2500 libpxart.pc \u2502 \u251c\u2500\u2500 libpxart.shared.pc \u2502 \u2514\u2500\u2500 libpxart.static.pc \u2514\u2500\u2500 share \u2514\u2500\u2500 doc \u2514\u2500\u2500 pxart \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 manifest \u2514\u2500\u2500 README.md Tests \u00b6 To run all the unit tests for all configurations, go into the tests package of the project folder and run the tests. cd tests bdep test -a Benchmarks \u00b6 Running the benchmarks for all configurations at the same time seems to be inconvenient. Therefore use the name to specify the configuration. To run the benchmarks, we use perfevent which calls perf in C++. We first have to allow the paranoid mode. sudo sysctl -w kernel.perf_event_paranoid=-1 Then go into the benchmarks package of the project folder and execute the benchmarks by using the build2. bdep test @gcc Examples \u00b6 Basics \u00b6 There is more than one example package. Typically, the executables of the examples have to be called manually. For the basics example, the test command can still be used. cd examples/basics bdep test @gcc Photon Propagation \u00b6 To run the photon propagation example in default configuration, do the following. cd examples/photon_propagation photons/photons","title":"Setup"},{"location":"development/setup/#setup","text":"","title":"Setup"},{"location":"development/setup/#clone-initialize-and-build","text":"By using build2, pxart can be easily tested with multiple configurations. For this, create a new folder pxart in your favorite project folder, like ~/projects . mkdir pxart We call this one the developer folder, because it will contain the actual Git repository of the code as well as all the configurations the tests will be built for. Go into this folder and clone this repository. cd pxart git clone https://github.com/lyrahgames/pxart We call this one the repository folder, the source folder, or the project folder. Change the directory into the source folder and create all the configurations that you would like to test for. In this example, we will create two configurations for the default GCC and Clang compiler with maximal optimization enabled. cd pxart bdep init -C @gcc cc config.cxx=g++ \"config.cxx.coptions=-03 -march=native\" config.install.root=../install bdep init -C @clang cc config.cxx=clang++ \"config.cxx.coptions=-03 -march=native\" These commands have create two configurations, namely @gcc and @clang , with their respective folders pxart-gcc and pxart-clang in the developer folder. The configuration @gcc is the default configuration and we have enabled local installation support for the folder named install inside the developer folder to be able to test the installation process. The folder structure should now look like the following. pxart/ # Developer Folder \u2502 \u251c\u2500\u2500 pxart/... # Project Folder \u2502 \u251c\u2500\u2500 pxart-gcc/... # Configuration Folder 'gcc' \u2502 \u2514\u2500\u2500 pxart-clang/... # Configuration Folder 'clang' To build all the packages of the project for all initialized configurations, run the following command. bdep update -a Furthermore, we would like to create symbolic links to the executable for the default configuration. For this, we have to run the build system of build2 directly. b To test the installation run the build system with the appropriate target. b install Your developer folder should now contain a folder, called install , with all installed packages. To only have a look at the library installation itself, uninstall all files and go into the library package inside the project folder and run the installation command again. b uninstall cd pxart b install The folder structure of install should look similar to the following. install/ \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 pxart/... # pXart Header Files \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 pkgconfig \u2502 \u251c\u2500\u2500 libpxart.pc \u2502 \u251c\u2500\u2500 libpxart.shared.pc \u2502 \u2514\u2500\u2500 libpxart.static.pc \u2514\u2500\u2500 share \u2514\u2500\u2500 doc \u2514\u2500\u2500 pxart \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 manifest \u2514\u2500\u2500 README.md","title":"Clone, Initialize, and Build"},{"location":"development/setup/#tests","text":"To run all the unit tests for all configurations, go into the tests package of the project folder and run the tests. cd tests bdep test -a","title":"Tests"},{"location":"development/setup/#benchmarks","text":"Running the benchmarks for all configurations at the same time seems to be inconvenient. Therefore use the name to specify the configuration. To run the benchmarks, we use perfevent which calls perf in C++. We first have to allow the paranoid mode. sudo sysctl -w kernel.perf_event_paranoid=-1 Then go into the benchmarks package of the project folder and execute the benchmarks by using the build2. bdep test @gcc","title":"Benchmarks"},{"location":"development/setup/#examples","text":"","title":"Examples"},{"location":"development/setup/#basics","text":"There is more than one example package. Typically, the executables of the examples have to be called manually. For the basics example, the test command can still be used. cd examples/basics bdep test @gcc","title":"Basics"},{"location":"development/setup/#photon-propagation","text":"To run the photon propagation example in default configuration, do the following. cd examples/photon_propagation photons/photons","title":"Photon Propagation"},{"location":"development/status/","text":"Status \u00b6 master Current Requirements \u00b6 Standard: C++17 Build System: build2 | CMake Intel Processor for Vectorized Components Tested Platforms \u00b6 Operating System: Linux | Window | MacOS Compiler: GCC | Clang | Intel | MinGW | MSVC","title":"Status"},{"location":"development/status/#status","text":"master Current","title":"Status"},{"location":"development/status/#requirements","text":"Standard: C++17 Build System: build2 | CMake Intel Processor for Vectorized Components","title":"Requirements"},{"location":"development/status/#tested-platforms","text":"Operating System: Linux | Window | MacOS Compiler: GCC | Clang | Intel | MinGW | MSVC","title":"Tested Platforms"}]}